```java
// 1. Loading
// JVM передает классы JvmComprehension, Object, Integer и System в подсистему загрузчиков классов
// Application ClassLoader (далее - CL) передает классы Extension CL
// Extension CL передает классы Bootstrap CL
// Bootstrap CL находит классы Object, Integer и System и загружает их, 
// но не находит класс JvmComprehension и передает его Extension CL
// Extension CL также не находит и передает его Application CL
// Application CL находит класс JvmComprehension и загружает его

// 2. Linking
// 2.1 Verification
// Байткод проверяется на валидность
// 2.2 Preparation
// Создаются статические поля классов и инициализируются значениями по умолчанию
// 2.3 Resolution
// Символьные ссылки на классы Object, Integer и System заменяются конкретными значениями

// 3. Initialization
// Всем статическим переменным присваиваются реальные значения
// Выполняются все инициализаторы статических полей

// 4. Данные о классах и константы загружаются в Metaspace

public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1 В Stack Memory (далее - SM) создается новый фрейм main(), внутри которого создается переменная i типа int, которой присваивается значение 1.
        Object o = new Object();        // 2 В heap создается новый объект типа Object, а в SM создается переменная o типа Object, в которую присваивается ссылка на новый объект
        Integer ii = 2;                 // 3 В heap создается новый объект типа Integer со значением 2, а в SM создается переменная ii типа Integer, в которую присваивается ссылка на новый объект
        printAll(o, i, ii);             // 4 В SM создается новый фрейм printAll(), куда передаются ссылки на объекты o и ii, и копируется значение переменной i
        System.out.println("finished"); // 7 В heap создается объект типа String со значением "finished",
        // а в SM создается новый фрейм println, куда передается ссылка типа String на объект "finished"
        // В консоли выводится значение строки, и фрейм println() удаляется из SM
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5 В heap создается новый объект типа Integer со значением 700, 
        // а в SM создается переменная uselessVar типа Integer, в которую присваивается ссылка на новый объект
        System.out.println(o.toString() + i + ii);  // 6 В SM создается новый фрейм println(), куда передаются ссылки на объекты o и ii, и копируется значение i
        // В процессе выполнения фрейма println() в heap создается новый объект типа StringBuilder, ссылка на который создается в SM внутри фрейма println()
        // В SM создается 1-й фрейм append(), куда передается ссылка на объект o
        // Cоздается фрейм toString(), в процессе выполнения которого, в heap создается новый объект типа String с названием класса объекта о и его хэш-кодом, а ссылка на объект типа String возвращается в фрейм append() и фрейм toString() удаляется из SM
        // 1-й фрейм append() возвращает объект StringBuilder с добавленным строковым значением объекта o и фрейм append() удаляется из SM
        // Создается 2-й фрейм append() куда передается значение i
        // 2-й фрейм append() возвращает объект StringBuilder с добавленным строковым значением i и фрейм append() удаляется из SM
        // Создается 3-й фрейм append() куда передается ссылка на объект ii
        // 3-й фрейм append() возвращает объект StringBuilder с добавленным строковым значением объекта ii и фрейм append() удаляется из SM
        // Создается фрейм toString(), в процессе выполнения которого, в heap создается новый объект типа String, который содержит все значения, добавленные в StringBuilder, а ссылка на объект типа String возвращается в фрейм println() и фрейм toString() удаляется из SM
        // В консоли выводится значение строки, и фрейм println() удаляется из SM
    }
}
```